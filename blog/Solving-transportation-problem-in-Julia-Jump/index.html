<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
     <link rel="stylesheet" href="/libs/katex/katex.min.css">
     
     <link rel="stylesheet" href="/libs/highlight/github.min.css">
   
    <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="/css/tufte.css">
<link rel="stylesheet" href="/css/latex.css">
<link rel="stylesheet" href="/css/adjust.css"> <!-- sheet to overwrite some clashing styles -->
<link rel="icon" href="/assets/favicon.png">

     <title>Solving transportation problems in Julia+JuMP</title>  
</head>

<body>
<div id="layout">
  <div id="menu">
    <ul>
      <li><a href="/">Home</a></li>
      <li><a href="/tags/">Tags</a></li>
    </ul>
  </div>
  <div id="main">



<!-- Content appended here -->
<div class="franklin-content"><h1 id="solving_transportation_problems_in_juliajump"><a href="#solving_transportation_problems_in_juliajump" class="header-anchor">Solving transportation problems in Julia&#43;JuMP</a></h1>
<p><strong>Shuvomoy Das Gupta</strong></p>
<p><em>February 3, 2021</em></p>
<p>In this blog, we will discuss how to solve a simple transportation problem  in <code>JuMP&#43;Julia</code>,  that exploits sparsity. This blog is based on an earlier notebook I created a few years ago. The blog is written using the package <code>Weave.jl</code>. </p>
<hr />
<p><strong>Table of contents</strong></p>
<div class="franklin-toc"><ol><li><a href="#introduction">Introduction</a></li><li><a href="#a_test_example_transportation_problem">A test example: transportation problem</a></li><li><a href="#defining_types_structures_via_struct">Defining types &#40;structures&#41; via <code>struct</code></a></li><li><a href="#creating_new_arrays_efficiently_from_existing_arrays">Creating new arrays efficiently from existing arrays</a></li><li><a href="#efficiently_constructing_dictionary_of_structs">Efficiently constructing dictionary of <code>struct</code>s</a></li><li><a href="#mathematical_representation_of_the_transportation_problem">Mathematical representation of the transportation problem</a></li><li><a href="#data_file">Data file</a></li><li><a href="#solve_using_jump">Solve using <code>JuMP</code></a></li></ol></div>
<hr />
<h4 id="introduction"><a href="#introduction" class="header-anchor">Introduction</a></h4>
<p><strong>What is a sparse data structure?</strong></p>
<p>A sparse data structure is one that has a lot of zeros in it. If a matrix has many more zeros than nonzeros, then it is a sparse matrix.</p>
<p><strong>Why do we need to exploit sparsity?</strong></p>
<ul>
<li><p>Sparsity in the input data increases with the dimension.</p>
</li>
<li><p>Exploiting sparsity</p>
<ul>
<li><p>keeps the data size small</p>
</li>
<li><p>saves memory</p>
</li>
<li><p>reduces the running time</p>
</li>
<li><p>improves the efficiency of the model</p>
</li>
</ul>
</li>
</ul>
<p><strong>How to exploit sparsity in Julia?</strong></p>
<ul>
<li><p>Define <code>struct</code> and create a <code>dictionary</code> or an <code>array</code> of it.</p>
</li>
</ul>
<h4 id="a_test_example_transportation_problem"><a href="#a_test_example_transportation_problem" class="header-anchor">A test example: transportation problem</a></h4>
<p>Consider a transportation problem which is going to be our test example:</p>
<ul>
<li><p><strong>Problem setup:</strong> Some products have to transported from origin cities to destination cities</p>
</li>
</ul>
<ul>
<li><p><strong>Objective:</strong></p>
</li>
<li><p>Minimize the total cost of shipment over all <strong>relevant</strong> routes</p>
</li>
</ul>
<ul>
<li><p><strong>Decision Variables</strong></p>
</li>
<li><p>Find the optimum amount of every product to be shipped from one city to another</p>
</li>
</ul>
<ul>
<li><p><strong>Constraints</strong></p>
</li>
<li><p>How much of a product a city can supply to other cities is fixed.</p>
</li>
<li><p>The amount of any product demanded by a city is also fixed.</p>
</li>
<li><p>The total amount of products shipped between every pair of different cities can not exceed a given limit.</p>
</li>
</ul>
<p>Suppose there are ten cities and three products in our problem.</p>
<pre><code class="language-julia">cities &#61;
&#91;
:BANGKOK; :LONDON; :PARIS; :SINGAPORE;  :NEWYORK;  :ISTANBUL;  :DUBAI;  :KUALALUMPUR;  :HONGKONG;  :BARCELONA
&#93;

products   &#61;
&#91;
:smartphone; :tablet; :laptop
&#93;</code></pre>
<h4 id="defining_types_structures_via_struct"><a href="#defining_types_structures_via_struct" class="header-anchor">Defining types &#40;structures&#41; via <code>struct</code></a></h4>
<p>If we do not exploit sparsity, then number of ways we can ship the products from one city to other will be \(3 \times (^{10}P_2+10)=300\).</p>
<p>Clearly many of them will be redundant, because of reasons like</p>
<ul>
<li><p>a product might not be needed by a city</p>
</li>
<li><p>a product might not be produced by a city etc.</p>
</li>
</ul>
<p>We just need to consider <em>relevant route</em>s, where a product can be shipped from one production city to the other demand city. So a <em>relevant route</em> can be defined by 3 features:</p>
<ul>
<li><p>a product</p>
</li>
<li><p>a city that produces that product</p>
</li>
<li><p>a city that demands that product</p>
</li>
</ul>
<p>So, we define an <code>struct</code> <code>Route</code> as follows:</p>
<pre><code class="language-julia">struct Route
  p::Symbol # p stands for product
  o::Symbol # o stands for origin
  d::Symbol # d stands for destination
end</code></pre>
<p>Here the datatype <code>Symbol</code> is a special type of immutable string. Then we create an array of only relevant routes.</p>
<pre><code class="language-julia">routesExample &#61;
&#91;
Route&#40;:smartphone,:BANGKOK,:SINGAPORE&#41;;
Route&#40;:smartphone,:BANGKOK,:NEWYORK&#41;;
Route&#40;:smartphone,:BANGKOK,:ISTANBUL&#41;;
Route&#40;:smartphone,:BANGKOK,:DUBAI&#41;;
&#93;</code></pre>
<p>If we want to access \(i\)th element of the array by typing in <code>routes&#91;i&#93;</code>. When we want to access the product name associated with the \(it\)h element of the array, we can do so by typing <code>routes&#91;i&#93;.p</code>.</p>
<pre><code class="language-julia">routesExample&#91;2&#93; # Will give the second route</code></pre>
<pre><code class="language-julia">routesExample&#91;4&#93;.d # Will give the demand city of the 4th route</code></pre>
<h4 id="creating_new_arrays_efficiently_from_existing_arrays"><a href="#creating_new_arrays_efficiently_from_existing_arrays" class="header-anchor">Creating new arrays efficiently from existing arrays</a></h4>
<p>Often we need to create new arrays, where the elements of them are extracted from some already existing array conditionally.</p>
<p>Consider the immutable type <code>Supply</code>.</p>
<pre><code class="language-julia">struct Supply
  p::Symbol # p stands for product name
  o::Symbol # o stands for the origin city
end</code></pre>
<p>We want to create an array <code>suppliesExample</code>, that contains all relevant product-city pairs, where the particular product is produced in that city. Clearly we can construct this array by plucking each product and corresponding city producing it from <code>routesExample</code>. This is how we do it efficiently:</p>
<ul>
<li><p>Create an empty array of type <code>Supply</code></p>
</li>
<li><p>Add elements to this array by</p>
</li>
</ul>
<ul>
<li><p>selecting the product and origin from the elements of <code>routes</code></p>
</li>
<li><p><em>push</em>ing them one by one in <code>supplies</code></p>
</li>
</ul>
<pre><code class="language-julia">suppliesExample &#61; Supply&#91;&#93; # Creates a 0 element array of immutable type Supply
for r in routesExample # For every element of the route route
  push&#33;&#40;suppliesExample, Supply&#40;r.p, r.o&#41;&#41; # pick the product and origin city and push it in  supplies
end</code></pre>
<pre><code class="language-julia">suppliesExample</code></pre>
<h4 id="efficiently_constructing_dictionary_of_structs"><a href="#efficiently_constructing_dictionary_of_structs" class="header-anchor">Efficiently constructing dictionary of <code>struct</code>s</a></h4>
<p><strong>What is a dictionary?</strong> A dictionary is a data type which can be useful in exploiting sparsity.</p>
<p><strong>Why is it needed?</strong> Often we might be interested to index a variable by a composite data type, rather than a number. For example, for the transportation problem in consideration, it would be more convenient to index the decision variables in the routes that are present. Let</p>
\[
\begin{align*}
R=\{(p,o,d) \in P \times C \times C: \text{product } p \text{ has to be transported from city } o \text{ to city } d\}
\end{align*}
\]
<p>be the set of all the routes that are relevant for the problem. So, we can define our decision variable \((x_{(p,o,d)})_{(p,o,d) \in R}\) â€‹  such that for any \((p,o,d)\in R\), the quantity \(x_{(p,o,d)}\) represents the amount of a product \(p\) that is transported from city \(o\)  to city \(d\). From a data structure point of view, \( \left(x_{(p,o,d)}\right)_{(p,o,d) \in R}\) is a dictionary which</p>
<ul>
<li><p>takes \((p,o,d) \in R\) as its <strong>key</strong> and</p>
</li>
<li><p>has the <strong>value</strong> the optimum amount of the product \(p\) to be shipped from city \(o\) to city \(d\).</p>
</li>
</ul>
<p><strong>Efficiently constructing dictionary of <code>struct</code>s.</strong> Suppose we want to create a dictionary  called <code>costRoutes</code>. Every element of the dictionary <code>costRoutes</code> contains the value of shipping cost along a particular route belonging to the array <code>routesExample</code>. So,</p>
<ul>
<li><p>the <strong>key</strong> to an element belonging to the dictionary is a specific route belonging to the array <code>routesExample</code>, and</p>
</li>
<li><p>the <strong>value</strong> is the cost for that shipment.</p>
</li>
</ul>
<p>Suppose the values of the costs are stored in an array named <code>costCofExample</code>.</p>
<pre><code class="language-julia">costCofExample &#61; &#91;120; 205; 310; 45.0&#93;</code></pre>
<p>We create the dictionary <code>costRoutes</code> similar to an array:</p>
<ul>
<li><p>we create an empty dictionary, and then</p>
</li>
<li><p>use the command</p>
</li>
</ul>
<p><code>setindex&#33;&#40;name_of_dictionary, value, key&#41;</code> or <code>name_of_dictionary&#91;key&#93;&#61;value</code> to add new elements in the dictionary one by one</p>
<pre><code class="language-julia">costRoutesExample&#61;Dict&#123;Route, Float64&#125;&#40;&#41;# Create an empty dictionary
# where the key is Route and the value is Float64
for i in 1:length&#40;routesExample&#41;
  costRoutesExample&#91;routesExample&#91;i&#93;&#93;&#61;costCofExample&#91;i&#93;
  # routesExample&#91;i&#93; is the key, and costCofExample&#91;i&#93; is the value
end</code></pre>
<pre><code class="language-julia">costRoutesExample</code></pre>
<p>After the dictionary is initialized, we can access the cost associated with some route <code>routes&#91;i&#93;</code> by typing in <code>costRoutes&#91;routes&#91;i&#93;&#93;</code></p>
<pre><code class="language-julia">costRoutesExample&#91;routesExample&#91;4&#93;&#93;</code></pre>
<p>Or we can input the description of the route itself:</p>
<pre><code class="language-julia">routesExample&#91;3&#93;
costRoutesExample&#91;Route&#40;:smartphone,:BANGKOK,:ISTANBUL&#41;&#93;</code></pre>
<h4 id="mathematical_representation_of_the_transportation_problem"><a href="#mathematical_representation_of_the_transportation_problem" class="header-anchor">Mathematical representation of the transportation problem</a></h4>
<p>The problem is a classic transportation problem. We will consider the sparse representation of the problem. Let</p>
\(C=\text{Set of all cities}\)
\(P=\text{Set of all products}\)
\(R=\{(p,o,d) \in P \times C \times C: \text{product } p \text{ has to be transported from city } o \text{ to city } d\} \)
\(\forall (p,o,d) \in R \quad \left(c_{(p,o,d)} = \text{cost of transporting some product } p \text{ from city } o \text{ to city } d \right)\)
\( \forall p \in P \quad \left(O_p = \text{Set of all origin cities where a product } p \text{ is produced}\right) \)
\( \forall p \in P \quad \left(D_p = \text{Set of all destination cities where a product } p \text{
  has to be delivered}\right) \)
\( \forall p \in P \; \forall o \in O_p \quad \left(s_{(p,o)} = \text{the total amount of the product } p \text{ that can be supplied by city } o\right) \)
\( \forall p \in P \; \forall d \in D_p \quad \left(d_{(p,d)} = \text{the total amount of the product } p \text{ that is demanded by city } d\right) \)
<p>Total amount of shipped product between each pair of cities cannot exceed \(\gamma\).</p>
<p>The decision variable for this problem is \( \left(x_{(p,o,d)}\right)_{(p,o,d) \in R}\), where</p>
\[
\begin{align*}
  \forall (p,o,d) \in R \quad \left(x_{(p,o,d)}= \text{the amount of a product } p \text{ that is trasported from city } o \text{ city d} \right).
  \end{align*}
\]
<p>The optimization problem can be described as below:</p>
\[
\begin{align*}
  &\text{minimize} && \sum_{(p,o,d) \in R}{c_{(p,o,d)} x_{(p,o,d)}} \\
  &\text{subject to} && \\
  &       && \forall p \in P \; \forall o \in O_p \quad \left(\sum_{d \in D_p} x_{(p,o,d)}=s_{(p,o)}\right) \\
  &       && \texttt{/*The amount of any product a city can supply to other cities is fixed */} \\
  &       && \forall p \in P \; \forall d \in D_p \quad \left(\sum_{o \in O_p}{x_{(p,o,d)}}=d_{(p,d)}\right) \\
  &       && \texttt{/* The amount of any product demanded by a city is also fixed.*/} \\
  &       && \forall o \in C \; \forall d \in C \setminus \{o\} \quad
  \left(\sum_{(p,\bar{o},\bar{d}) \in R \; : \; o=\bar{o} \wedge d=\bar{d}}{x_{(p,\bar{o},\bar{d})}}\leq \gamma\right) \\
&       && \texttt{/* The total amount of products shipped between every pair} \\& &&\texttt{of different cities can not exceed a given limit.*/}
\end{align*}
\]
<p><strong>Mapping of the mathematical symbols to JuMP</strong></p>
<p>In the data file, the symbols in the model above are mapped as follows:</p>
<table><tr><th align="right">Symbol</th><th align="right">In the code</th><th align="right">Comment</th></tr><tr><td align="right">\(C\)</td><td align="right"><code>cities</code></td><td align="right"><code>cities</code> is an array of <code>Symbol</code>s</td></tr><tr><td align="right">\(P\)</td><td align="right"><code>products</code></td><td align="right"><code>products</code> is an array of <code>Symbol</code>s</td></tr><tr><td align="right">\(R\)</td><td align="right"><code>routes</code></td><td align="right"><code>routes</code> is an array of immutable type <code>Route</code></td></tr><tr><td align="right">\((O_p)_{p \in P}\)</td><td align="right"><code>orig</code></td><td align="right"><code>orig</code> is a dictionary</td></tr><tr><td align="right">\((D_p)_{p \in P}\)</td><td align="right"><code>dest</code></td><td align="right"><code>dest</code> is a dictionary</td></tr><tr><td align="right">\(((s_{(p,o)})_{o \in O_p})_{p \in P}\)</td><td align="right"><code>suppliedAmount</code></td><td align="right"><code>suppliedAmount</code> is a dictionary</td></tr><tr><td align="right">\(((d_{(p,d)})_{d \in D_p})_{p \in P}\)</td><td align="right"><code>demandedAmount</code></td><td align="right"><code>demandedAmount</code> is a dictionary with key <code>Customer</code> and value <code>Float64</code></td></tr><tr><td align="right">\((x_{(p,o,d)})_{(p,o,d) \in R}\)</td><td align="right"><code>opt_prod</code></td><td align="right"><code>opt_prod</code> is a dictionary and the variable in the problem</td></tr><tr><td align="right">\((c_{(p,o,d)})_{(p,o,d) \in R}\)</td><td align="right"><code>costRoutes</code></td><td align="right"><code>costRoutes</code> is a dictionary</td></tr><tr><td align="right">\(\gamma\)</td><td align="right"><code>capacity</code></td><td align="right">It is of type <code>Float64</code></td></tr></table>
<h4 id="data_file"><a href="#data_file" class="header-anchor">Data file</a></h4>
<pre><code class="language-julia">cities &#61;
&#91;
:BANGKOK; :LONDON; :PARIS; :SINGAPORE;  :NEWYORK;  :ISTANBUL;  :DUBAI;  :KUALALUMPUR;  :HONGKONG;  :BARCELONA
&#93;

products   &#61;
&#91;
:smartphone; :tablet; :laptop
&#93;

capacity    &#61; 700

struct Route
  p::Symbol # p stands for product
  o::Symbol # o stands for origin
  d::Symbol # d stands for destination
end

routes &#61;
&#91;
Route&#40;:smartphone,:BANGKOK,:SINGAPORE&#41;;
Route&#40;:smartphone,:BANGKOK,:NEWYORK&#41;;
Route&#40;:smartphone,:BANGKOK,:ISTANBUL&#41;;
Route&#40;:smartphone,:BANGKOK,:DUBAI&#41;;
Route&#40;:smartphone,:BANGKOK,:KUALALUMPUR&#41;;
Route&#40;:smartphone,:BANGKOK,:HONGKONG&#41;;
Route&#40;:smartphone,:BANGKOK,:BARCELONA&#41;;
Route&#40;:smartphone,:LONDON,:SINGAPORE&#41;;
Route&#40;:smartphone,:LONDON,:NEWYORK&#41;;
Route&#40;:smartphone,:LONDON,:ISTANBUL&#41;;
Route&#40;:smartphone,:LONDON,:DUBAI&#41;;
Route&#40;:smartphone,:LONDON,:KUALALUMPUR&#41;;
Route&#40;:smartphone,:LONDON,:HONGKONG&#41;;
Route&#40;:smartphone,:LONDON,:BARCELONA&#41;;
Route&#40;:smartphone,:PARIS,:SINGAPORE&#41;;
Route&#40;:smartphone,:PARIS,:NEWYORK&#41;;
Route&#40;:smartphone,:PARIS,:ISTANBUL&#41;;
Route&#40;:smartphone,:PARIS,:DUBAI&#41;;
Route&#40;:smartphone,:PARIS,:KUALALUMPUR&#41;;
Route&#40;:smartphone,:PARIS,:HONGKONG&#41;;
Route&#40;:smartphone,:PARIS,:BARCELONA&#41;;

Route&#40;:tablet,:BANGKOK,:SINGAPORE&#41;;
Route&#40;:tablet,:BANGKOK,:NEWYORK&#41;;
Route&#40;:tablet,:BANGKOK,:ISTANBUL&#41;;
Route&#40;:tablet,:BANGKOK,:DUBAI&#41;;
Route&#40;:tablet,:BANGKOK,:KUALALUMPUR&#41;;
Route&#40;:tablet,:BANGKOK,:HONGKONG&#41;;
Route&#40;:tablet,:BANGKOK,:BARCELONA&#41;;

Route&#40;:tablet,:LONDON,:SINGAPORE&#41;;
Route&#40;:tablet,:LONDON,:NEWYORK&#41;;
Route&#40;:tablet,:LONDON,:ISTANBUL&#41;;
Route&#40;:tablet,:LONDON,:DUBAI&#41;;
Route&#40;:tablet,:LONDON,:KUALALUMPUR&#41;;
Route&#40;:tablet,:LONDON,:HONGKONG&#41;;
Route&#40;:tablet,:LONDON,:BARCELONA&#41;;

Route&#40;:tablet,:PARIS,:SINGAPORE&#41;;
Route&#40;:tablet,:PARIS,:NEWYORK&#41;;
Route&#40;:tablet,:PARIS,:ISTANBUL&#41;;
Route&#40;:tablet,:PARIS,:DUBAI&#41;;
Route&#40;:tablet,:PARIS,:KUALALUMPUR&#41;;
Route&#40;:tablet,:PARIS,:HONGKONG&#41;;
Route&#40;:tablet,:PARIS,:BARCELONA&#41;;

Route&#40;:laptop,:BANGKOK,:SINGAPORE&#41;;
Route&#40;:laptop,:BANGKOK,:NEWYORK&#41;;
Route&#40;:laptop,:BANGKOK,:ISTANBUL&#41;;
Route&#40;:laptop,:BANGKOK,:DUBAI&#41;;
Route&#40;:laptop,:BANGKOK,:KUALALUMPUR&#41;;
Route&#40;:laptop,:BANGKOK,:HONGKONG&#41;;
Route&#40;:laptop,:BANGKOK,:BARCELONA&#41;;

Route&#40;:laptop,:LONDON,:SINGAPORE&#41;;
Route&#40;:laptop,:LONDON,:NEWYORK&#41;;
Route&#40;:laptop,:LONDON,:ISTANBUL&#41;;
Route&#40;:laptop,:LONDON,:DUBAI&#41;;
Route&#40;:laptop,:LONDON,:KUALALUMPUR&#41;;
Route&#40;:laptop,:LONDON,:HONGKONG&#41;;
Route&#40;:laptop,:LONDON,:BARCELONA&#41;;

Route&#40;:laptop,:PARIS,:SINGAPORE&#41;;
Route&#40;:laptop,:PARIS,:NEWYORK&#41;;
Route&#40;:laptop,:PARIS,:ISTANBUL&#41;;
Route&#40;:laptop,:PARIS,:DUBAI&#41;;
Route&#40;:laptop,:PARIS,:KUALALUMPUR&#41;;
Route&#40;:laptop,:PARIS,:HONGKONG&#41;;
Route&#40;:laptop,:PARIS,:BARCELONA&#41;;
&#93;

struct Supply
  p::Symbol
  o::Symbol
end

#Creating the array supplies
#                   --------
supplies &#61; Supply&#91;&#93; # Creates a 0 element array of immutable type Supply
for r in routes
  push&#33;&#40;supplies, Supply&#40;r.p, r.o&#41;&#41;
end

# Creating suppliedAmount dictionary
#          --------------
#It might be better to create this as a dictionary, where the key is the
# element of the array supplies and the value is the corresponding supplied
#amount


suppliedAmount &#61; Dict&#123;Supply, Float64&#125;&#40;&#41;
for s in supplies
  if s.p &#61;&#61; :smartphone &amp;&amp; s.o &#61;&#61; :LONDON
    suppliedAmount&#91;s&#93;&#61;800
  elseif s.p &#61;&#61; :smartphone &amp;&amp; s.o&#61;&#61;:BANGKOK
    suppliedAmount&#91;s&#93;&#61;500
  elseif s.p &#61;&#61; :smartphone &amp;&amp; s.o&#61;&#61;:PARIS
    suppliedAmount&#91;s&#93;&#61;600
  elseif s.p &#61;&#61; :tablet &amp;&amp; s.o&#61;&#61;:BANGKOK
    suppliedAmount&#91;s&#93;&#61;1000
  elseif s.p &#61;&#61; :tablet &amp;&amp; s.o&#61;&#61;:LONDON
    suppliedAmount&#91;s&#93;&#61;1500
  elseif s.p &#61;&#61; :tablet &amp;&amp; s.o &#61;&#61; :PARIS
    suppliedAmount&#91;s&#93;&#61;1700
  elseif s.p &#61;&#61; :laptop &amp;&amp; s.o &#61;&#61; :BANGKOK
    suppliedAmount&#91;s&#93;&#61;150
  elseif s.p &#61;&#61; :laptop &amp;&amp; s.o &#61;&#61; :LONDON
    suppliedAmount&#91;s&#93;&#61;250
  elseif s.p &#61;&#61; :laptop &amp;&amp; s.o &#61;&#61; :PARIS
    suppliedAmount&#91;s&#93;&#61;400
  end #if
end #for

struct Customer
  p::Symbol
  d::Symbol
end

# Creating customers array, which is an array of custom immutable Customer
#          ---------
customers &#61; Customer&#91;&#93;
for r in routes
  push&#33;&#40;customers, Customer&#40;r.p, r.d&#41;&#41;
end


demandedAmount &#61; Dict&#123;Customer, Float64&#125;&#40;&#41;
for c in customers
  #1
  if c.p&#61;&#61;:smartphone &amp;&amp; c.d&#61;&#61;:SINGAPORE
    demandedAmount&#91;c&#93;&#61;400
    #2
  elseif c.p&#61;&#61;:tablet &amp;&amp; c.d&#61;&#61;:SINGAPORE
    demandedAmount&#91;c&#93;&#61;600
    #3
  elseif c.p&#61;&#61;:laptop &amp;&amp; c.d&#61;&#61;:SINGAPORE
    demandedAmount&#91;c&#93;&#61;90
    #4
  elseif c.p&#61;&#61;:smartphone &amp;&amp; c.d&#61;&#61;:NEWYORK
    demandedAmount&#91;c&#93;&#61;200
    #5
  elseif c.p&#61;&#61;:tablet &amp;&amp; c.d&#61;&#61;:NEWYORK
    demandedAmount&#91;c&#93;&#61;650
    #6
  elseif c.p&#61;&#61;:laptop &amp;&amp; c.d&#61;&#61;:NEWYORK
    demandedAmount&#91;c&#93;&#61;110
    #7
  elseif c.p&#61;&#61;:smartphone &amp;&amp; c.d&#61;&#61;:ISTANBUL
    demandedAmount&#91;c&#93;&#61;100
    #8
  elseif c.p&#61;&#61;:tablet &amp;&amp; c.d&#61;&#61;:ISTANBUL
    demandedAmount&#91;c&#93;&#61;300
    #9
  elseif c.p&#61;&#61;:laptop &amp;&amp; c.d&#61;&#61;:ISTANBUL
    demandedAmount&#91;c&#93;&#61;0
    #10
  elseif c.p&#61;&#61;:smartphone &amp;&amp; c.d&#61;&#61;:DUBAI
    demandedAmount&#91;c&#93;&#61;175
    #11
  elseif c.p&#61;&#61;:tablet &amp;&amp; c.d&#61;&#61;:DUBAI
    demandedAmount&#91;c&#93;&#61;350
    #12
  elseif c.p&#61;&#61;:laptop &amp;&amp; c.d&#61;&#61;:DUBAI
    demandedAmount&#91;c&#93;&#61;65
    #13
  elseif c.p&#61;&#61;:smartphone &amp;&amp; c.d&#61;&#61;:KUALALUMPUR
    demandedAmount&#91;c&#93;&#61;550
    #14
  elseif c.p&#61;&#61;:tablet &amp;&amp; c.d&#61;&#61;:KUALALUMPUR
    demandedAmount&#91;c&#93;&#61;950
    #15
  elseif c.p&#61;&#61;:laptop &amp;&amp; c.d&#61;&#61;:KUALALUMPUR
    demandedAmount&#91;c&#93;&#61;185
    #16
  elseif c.p&#61;&#61;:smartphone &amp;&amp; c.d&#61;&#61;:HONGKONG
    demandedAmount&#91;c&#93;&#61;200
    #17
  elseif c.p&#61;&#61;:tablet &amp;&amp; c.d&#61;&#61;:HONGKONG
    demandedAmount&#91;c&#93;&#61;750
    #18
  elseif c.p&#61;&#61;:laptop &amp;&amp; c.d&#61;&#61;:HONGKONG
    demandedAmount&#91;c&#93;&#61;150
    #19
  elseif c.p&#61;&#61;:smartphone &amp;&amp; c.d&#61;&#61;:BARCELONA
    demandedAmount&#91;c&#93;&#61;275
    #20
  elseif c.p&#61;&#61;:tablet &amp;&amp; c.d&#61;&#61;:BARCELONA
    demandedAmount&#91;c&#93;&#61;600
    #21
  elseif c.p&#61;&#61;:laptop &amp;&amp; c.d&#61;&#61;:BARCELONA
    demandedAmount&#91;c&#93;&#61;200
  end
end


costCof &#61;
&#91;34; 7; 8; 10; 11; 74; 9; 18; 5; 15; 6; 23; 81; 18; 20; 10; 9;
13; 25; 85; 13; 40; 17; 7; 16; 20; 80; 9; 24; 5; 15; 11; 23;
90; 22; 19; 15; 16; 15; 24; 100; 21; 37; 12; 9; 16; 14;
88; 9; 28; 13; 17; 8; 32; 100; 18; 28; 15; 18; 16; 30; 102; 15&#93;

# Creating costRoutes dictionary which contains the costs of the relevant routes
costRoutes&#61;Dict&#123;Route, Float64&#125;&#40;&#41;
for i in 1:length&#40;routes&#41;
  costRoutes&#91;routes&#91;i&#93;&#93;&#61;costCof&#91;i&#93;
end

# Creating orig, which takes the product as the input and gives the set of origins of that product

orig &#61; Dict&#123;Symbol, Array&#125;&#40;&#41;
for i in 1:length&#40;products&#41;
  dummy_array &#61; Symbol&#91;&#93;
  for j in 1:length&#40;routes&#41;
    #println&#40;i, j, products&#91;i&#93; &#61;&#61; routes&#91;j&#93;.p&#41;
    if products&#91;i&#93; &#61;&#61; routes&#91;j&#93;.p
      push&#33;&#40;dummy_array, routes&#91;j&#93;.o&#41;
      #println&#40;orig&#91;products&#91;i&#93;&#93;&#41;
    else
      #println&#40;&quot;Oops, something is not right&quot;&#41;
    end #if
  end #for
  orig&#91;products&#91;i&#93;&#93;&#61;unique&#40;dummy_array&#41;
end #for

# Creating dest, which takes the product as the input and gives the set of destinations of that product

dest &#61; Dict&#123;Symbol, Array&#125;&#40;&#41;
for i in 1:length&#40;products&#41;
  dummy_array &#61; Symbol&#91;&#93;
  for j in 1:length&#40;routes&#41;
    #println&#40;i, j, products&#91;i&#93; &#61;&#61; routes&#91;j&#93;.p&#41;
    if products&#91;i&#93; &#61;&#61; routes&#91;j&#93;.p
      push&#33;&#40;dummy_array, routes&#91;j&#93;.d&#41;
      #println&#40;orig&#91;products&#91;i&#93;&#93;&#41;
    else
      #println&#40;&quot;Oops, something is not right&quot;&#41;
    end #if
  end #for
  dest&#91;products&#91;i&#93;&#93;&#61;unique&#40;dummy_array&#41;
end #for</code></pre>
<h4 id="solve_using_jump"><a href="#solve_using_jump" class="header-anchor">Solve using <code>JuMP</code></a></h4>
<pre><code class="language-julia"># Load packages
using JuMP, COSMO

# Model name
transpModel &#61; Model&#40;COSMO.Optimizer&#41;

# Variable
@variable&#40;transpModel, opt_prod&#91;routes&#93; &gt;&#61; 0&#41;

# Objective
@objective&#40;transpModel, Min, sum&#40;costRoutes&#91;l&#93;*opt_prod&#91;l&#93; for l in routes&#41;&#41;

# First Constraint
for pr in products
  for org in orig&#91;pr&#93;
    @constraint&#40;transpModel, sum&#40;opt_prod&#91;Route&#40;pr, org, de&#41;&#93; for de in dest&#91;pr&#93;&#41;
    &#61;&#61;
    suppliedAmount&#91;Supply&#40;pr,org&#41;&#93;&#41;
  end
end

#Second Constraint
for pr in products
  for de in dest&#91;pr&#93;
    @constraint&#40;transpModel, sum&#40;opt_prod&#91;Route&#40;pr, org, de&#41;&#93; for org in orig&#91;pr&#93;&#41;
    &#61;&#61;
    demandedAmount&#91;Customer&#40;pr,de&#41;&#93;&#41;
  end
end

# Final constraint:
for org in cities
  for de in cities
    if org&#33;&#61;de
      @constraint&#40;transpModel,
      sum&#40;
      opt_prod&#91;r&#93; for r in routes
      if r.o &#61;&#61; org &amp;&amp; r.d&#61;&#61;de # This will be used as an filtering condition
        &#41;
        &lt;&#61;
        capacity&#41;
      else
        continue
      end
    end
  end

  statusMipModel &#61; optimize&#33;&#40;transpModel&#41; # solves the model

  println&#40;&quot;The optimal objective value is: &quot;, value.&#40;trans&#41;&#41;

  println&#40;&quot;The optimal solution is, trans&#61; \n&quot;, objective_value&#40;transpModel&#41;&#41;</code></pre>
<p><strong>Converting .jmd file to .jl file</strong> To convert the .jmd file to a .jl file we run the following code:</p>
<pre><code class="language-julia">using Weave
cd&#40;&quot;C:\\Users\\shuvo\\Desktop&quot;&#41; # directory that contains the .jmd file
tangle&#40;&quot;Exploiting_sparsity_in_Julia_JuMP.jmd&quot;, informat &#61; &quot;markdown&quot;&#41; # convert the .jmd file into a .jl file that will contain the code</code></pre>
<div class="page-foot">
  <div class="copyright">
    &copy; Shuvomoy Das Gupta. Last modified: May 18, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div><!-- CONTENT ENDS HERE -->
        </div> <!-- end of id=main -->
    </div> <!-- end of id=layout -->
    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        <script src="/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>
